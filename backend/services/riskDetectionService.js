const Student = require('../models/Student');
const Attendance = require('../models/Attendance');
const Performance = require('../models/Performance');
const RiskFlag = require('../models/RiskFlag');
const Settings = require('../models/Settings');
const logger = require('../utils/logger');

class RiskDetectionService {
  /**
   * Run risk detection for a specific student
   */
  async detectRisksForStudent(studentId, schoolId, userId) {
    try {
      const student = await Student.findById(studentId);
      if (!student) {
        throw new Error('Student not found');
      }

      const settings = await Settings.getOrCreateForSchool(schoolId);
      const risks = [];

      // Check attendance risks
      if (settings.riskRules.attendance.enabled) {
        const attendanceRisk = await this.checkAttendanceRisk(studentId, settings.riskRules.attendance);
        if (attendanceRisk) {
          risks.push(attendanceRisk);
        }
      }

      // Check performance risks
      if (settings.riskRules.performance.enabled) {
        const performanceRisk = await this.checkPerformanceRisk(studentId, settings.riskRules.performance);
        if (performanceRisk) {
          risks.push(performanceRisk);
        }
      }

      // Check socioeconomic risks
      if (settings.riskRules.socioeconomic.enabled) {
        const socioeconomicRisk = await this.checkSocioeconomicRisk(student, settings.riskRules.socioeconomic);
        if (socioeconomicRisk) {
          risks.push(socioeconomicRisk);
        }
      }

      // Check distance to school risks
      const distanceRisk = await this.checkDistanceRisk(student);
      if (distanceRisk) {
        risks.push(distanceRisk);
      }

      // Check combined risks
      if (settings.riskRules.combined.enabled && risks.length >= 2) {
        const combinedRisk = await this.checkCombinedRisk(risks, settings.riskRules.combined);
        if (combinedRisk) {
          risks.push(combinedRisk);
        }
      }

      // Create risk flags for new risks
      const createdFlags = [];
      for (const risk of risks) {
        // Check if similar flag already exists
        const existingFlag = await RiskFlag.findOne({
          studentId,
          type: risk.type,
          isActive: true,
          severity: risk.severity
        });

        if (!existingFlag) {
          const flag = await RiskFlag.create({
            studentId,
            schoolId,
            ...risk,
            createdBy: userId,
            autoGenerated: true
          });
          createdFlags.push(flag);

          // Notify admins immediately for HIGH and CRITICAL risk flags
          if (['HIGH', 'CRITICAL'].includes(risk.severity)) {
            const { notifyAdminOfStudentRisk } = require('../utils/adminNotificationService');
            await notifyAdminOfStudentRisk(
              studentId,
              risk.severity,
              `New ${risk.severity} risk flag detected: ${risk.title}. ${risk.description}`,
              risk.type
            );

            // Automatically notify parents/guardians for HIGH and CRITICAL risk flags
            const { notifyParentsOfRisk } = require('../utils/notificationService');
            const riskDescription = `${risk.title}. ${risk.description}`;
            notifyParentsOfRisk(studentId, risk.severity, riskDescription).catch(err => {
              logger.error('Error notifying parents of new risk flag:', err);
            });
          }
        }
      }

      // Update student risk level (this will also notify admins if overall risk is at-risk)
      await this.updateStudentRiskLevel(studentId);

      logger.info(`Risk detection completed for student ${studentId}`, {
        risksDetected: risks.length,
        flagsCreated: createdFlags.length
      });

      return {
        risksDetected: risks.length,
        flagsCreated: createdFlags.length,
        flags: createdFlags
      };
    } catch (error) {
      logger.error(`Risk detection failed for student ${studentId}:`, error);
      throw error;
    }
  }

  /**
   * Check attendance-based risks
   */
  async checkAttendanceRisk(studentId, rules) {
    const patterns = await Attendance.checkAbsenteeismPattern(studentId, rules.highThreshold.withinDays);

    if (patterns.absences >= rules.criticalThreshold.absences) {
      return {
        type: 'ATTENDANCE',
        severity: 'CRITICAL',
        title: `Critical Absenteeism: ${patterns.absences} absences`,
        description: `Student has been absent ${patterns.absences} times in the last ${rules.criticalThreshold.withinDays} days, indicating critical dropout risk.`,
        data: {
          attendanceData: {
            absences: patterns.absences,
            period: `${rules.criticalThreshold.withinDays} days`,
            dates: patterns.dates
          }
        }
      };
    } else if (patterns.absences >= rules.highThreshold.absences) {
      return {
        type: 'ATTENDANCE',
        severity: 'HIGH',
        title: `High Absenteeism: ${patterns.absences} absences`,
        description: `Student has been absent ${patterns.absences} times in the last ${rules.highThreshold.withinDays} days, indicating high dropout risk.`,
        data: {
          attendanceData: {
            absences: patterns.absences,
            period: `${rules.highThreshold.withinDays} days`,
            dates: patterns.dates
          }
        }
      };
    } else if (patterns.absences >= rules.mediumThreshold.absences) {
      return {
        type: 'ATTENDANCE',
        severity: 'MEDIUM',
        title: `Moderate Absenteeism: ${patterns.absences} absences`,
        description: `Student has been absent ${patterns.absences} times in the last ${rules.mediumThreshold.withinDays} days. Monitor closely.`,
        data: {
          attendanceData: {
            absences: patterns.absences,
            period: `${rules.mediumThreshold.withinDays} days`,
            dates: patterns.dates
          }
        }
      };
    }

    return null;
  }

  /**
   * Check performance-based risks
   */
  async checkPerformanceRisk(studentId, rules) {
    // Get recent performance records
    const currentYear = new Date().getFullYear();
    const recentPerformances = await Performance.find({
      studentId,
      academicYear: `${currentYear}/${currentYear + 1}`
    }).sort({ createdAt: -1 });

    if (recentPerformances.length === 0) {
      return null;
    }

    // Count failing grades
    const failingGrades = recentPerformances.filter(p => p.grade === 'F' || p.grade === 'E').length;
    
    if (failingGrades >= (rules.criticalThreshold.multipleFailures || 3)) {
      return {
        type: 'PERFORMANCE',
        severity: 'CRITICAL',
        title: `Critical Performance: ${failingGrades} failing grades`,
        description: `Student has ${failingGrades} failing grades, indicating critical academic risk.`,
        data: {
          performanceData: {
            failingGrades,
            subjects: recentPerformances.filter(p => p.grade === 'F' || p.grade === 'E').map(p => p.subject)
          }
        }
      };
    }

    // Check for score drops
    const subjects = [...new Set(recentPerformances.map(p => p.subject))];
    for (const subject of subjects) {
      const subjectPerformances = recentPerformances
        .filter(p => p.subject === subject)
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      if (subjectPerformances.length >= 2) {
        const current = subjectPerformances[0];
        const previous = subjectPerformances[1];
        const drop = previous.score - current.score;

        if (drop >= rules.highThreshold.scoreDrop) {
          return {
            type: 'PERFORMANCE',
            severity: 'HIGH',
            title: `Significant Score Drop in ${subject}`,
            description: `Score dropped by ${drop} points from ${previous.score} to ${current.score} in ${subject}.`,
            data: {
              performanceData: {
                subject,
                currentScore: current.score,
                previousScore: previous.score,
                drop
              }
            }
          };
        } else if (drop >= rules.mediumThreshold.scoreDrop) {
          return {
            type: 'PERFORMANCE',
            severity: 'MEDIUM',
            title: `Score Drop in ${subject}`,
            description: `Score dropped by ${drop} points from ${previous.score} to ${current.score} in ${subject}. Monitor progress.`,
            data: {
              performanceData: {
                subject,
                currentScore: current.score,
                previousScore: previous.score,
                drop
              }
            }
          };
        }
      }
    }

    return null;
  }

  /**
   * Check socioeconomic risks
   */
  async checkSocioeconomicRisk(student, rules) {
    const riskFactors = [];

    if (student.socioEconomic.ubudeheLevel <= rules.highRiskFactors.ubudeheLevel) {
      riskFactors.push(`Ubudehe Level ${student.socioEconomic.ubudeheLevel} (extreme poverty)`);
    }

    if (!student.socioEconomic.hasParents && rules.highRiskFactors.noParents) {
      riskFactors.push('No parents (orphan)');
    }

    // Family stability: false (unstable) = risk, true (stable) = no risk
    if (!student.socioEconomic.familyStability && rules.highRiskFactors.familyStability) {
      riskFactors.push('Family stability concerns reported');
    }

    if (riskFactors.length >= 2) {
      return {
        type: 'SOCIOECONOMIC',
        severity: 'HIGH',
        title: 'Multiple Socioeconomic Risk Factors',
        description: `Student has multiple socioeconomic risk factors: ${riskFactors.join(', ')}`,
        data: {
          socioeconomicData: {
            ubudeheLevel: student.socioEconomic.ubudeheLevel,
            hasParents: student.socioEconomic.hasParents,
            familyStability: student.socioEconomic.familyStability,
            riskFactors
          }
        }
      };
    } else if (riskFactors.length === 1) {
      return {
        type: 'SOCIOECONOMIC',
        severity: 'MEDIUM',
        title: 'Socioeconomic Risk Factor',
        description: `Student has a socioeconomic risk factor: ${riskFactors[0]}`,
        data: {
          socioeconomicData: {
            ubudeheLevel: student.socioEconomic.ubudeheLevel,
            hasParents: student.socioEconomic.hasParents,
            familyStability: student.socioEconomic.familyStability,
            riskFactors
          }
        }
      };
    }

    return null;
  }

  /**
   * Check distance to school risks
   */
  async checkDistanceRisk(student) {
    if (!student.socioEconomic.distanceToSchoolKm) {
      return null;
    }

    const distance = student.socioEconomic.distanceToSchoolKm;

    if (distance >= 7) {
      return {
        type: 'DISTANCE',
        severity: 'CRITICAL',
        title: `Critical Distance: ${distance} km from school`,
        description: `Student lives ${distance} kilometers from school, exceeding the critical threshold of 7 km. This distance creates significant barriers to regular attendance.`,
        data: {
          distanceData: {
            distanceKm: distance,
            threshold: 7,
            riskLevel: 'CRITICAL'
          }
        }
      };
    } else if (distance >= 5) {
      return {
        type: 'DISTANCE',
        severity: 'HIGH',
        title: `High Distance: ${distance} km from school`,
        description: `Student lives ${distance} kilometers from school, indicating high dropout risk due to distance barriers.`,
        data: {
          distanceData: {
            distanceKm: distance,
            threshold: 5,
            riskLevel: 'HIGH'
          }
        }
      };
    } else if (distance >= 3) {
      return {
        type: 'DISTANCE',
        severity: 'MEDIUM',
        title: `Moderate Distance: ${distance} km from school`,
        description: `Student lives ${distance} kilometers from school. Monitor attendance patterns closely.`,
        data: {
          distanceData: {
            distanceKm: distance,
            threshold: 3,
            riskLevel: 'MEDIUM'
          }
        }
      };
    }

    return null;
  }

  /**
   * Check combined risks (escalate severity)
   */
  async checkCombinedRisk(risks, rules) {
    const mediumRisks = risks.filter(r => r.severity === 'MEDIUM');
    const hasAttendance = risks.some(r => r.type === 'ATTENDANCE');
    const hasPerformance = risks.some(r => r.type === 'PERFORMANCE');

    if (mediumRisks.length >= rules.escalateWhen.multipleMediumFlags) {
      return {
        type: 'COMBINED',
        severity: 'HIGH',
        title: 'Multiple Risk Factors Detected',
        description: `Student has ${mediumRisks.length} medium-risk factors that together indicate high dropout risk.`,
        data: {
          additionalInfo: {
            riskTypes: risks.map(r => r.type),
            escalationReason: 'Multiple medium-risk factors'
          }
        }
      };
    }

    if (hasAttendance && hasPerformance && rules.escalateWhen.attendanceAndPerformance) {
      return {
        type: 'COMBINED',
        severity: 'HIGH',
        title: 'Attendance and Performance Issues',
        description: 'Student has both attendance and performance issues, indicating high dropout risk.',
        data: {
          additionalInfo: {
            riskTypes: risks.map(r => r.type),
            escalationReason: 'Combined attendance and performance issues'
          }
        }
      };
    }

    return null;
  }

  /**
   * Update student risk level based on active flags
   */
  async updateStudentRiskLevel(studentId) {
    const summary = await RiskFlag.getStudentSummary(studentId);
    const student = await Student.findById(studentId);
    
    if (student) {
      const previousRiskLevel = student.riskLevel;
      student.riskLevel = summary.overallRisk;
      await student.save();

      // Notify admins if risk level changed to or is at-risk
      if (['MEDIUM', 'HIGH', 'CRITICAL'].includes(summary.overallRisk)) {
        const { notifyAdminOfStudentRisk } = require('../utils/adminNotificationService');
        let reason = '';
        if (previousRiskLevel !== summary.overallRisk) {
          reason = `Risk level changed from ${previousRiskLevel || 'LOW'} to ${summary.overallRisk}.`;
        } else {
          reason = `Student has active risk flags with ${summary.overallRisk} risk level.`;
        }
        
        // Determine risk type from flags
        const activeFlags = await RiskFlag.find({ studentId, isActive: true, isResolved: false });
        const riskTypes = [...new Set(activeFlags.map(f => f.type))];
        const riskType = riskTypes.length > 0 ? riskTypes[0] : 'GENERAL';
        
        await notifyAdminOfStudentRisk(studentId, summary.overallRisk, reason, riskType);

        // Automatically notify parents/guardians if risk level changed to HIGH or CRITICAL
        if (previousRiskLevel !== summary.overallRisk && (summary.overallRisk === 'HIGH' || summary.overallRisk === 'CRITICAL')) {
          const { notifyParentsOfRisk } = require('../utils/notificationService');
          notifyParentsOfRisk(studentId, summary.overallRisk, reason).catch(err => {
            logger.error('Error notifying parents of risk level change:', err);
          });
        }
      }
    }

    return summary.overallRisk;
  }

  /**
   * Run risk detection for all students in a school
   */
  async detectRisksForSchool(schoolId, userId) {
    try {
      const students = await Student.find({ schoolId, isActive: true });
      
      logger.info(`Starting risk detection for ${students.length} students in school ${schoolId}`);

      let processed = 0;
      let flagsCreated = 0;

      for (const student of students) {
        try {
          const result = await this.detectRisksForStudent(student._id, schoolId, userId);
          flagsCreated += result.flagsCreated;
          processed++;
        } catch (error) {
          logger.error(`Failed to detect risks for student ${student._id}:`, error);
        }
      }

      logger.info(`Risk detection completed for school ${schoolId}`, {
        studentsProcessed: processed,
        totalFlagsCreated: flagsCreated
      });

      return {
        studentsProcessed: processed,
        totalFlagsCreated: flagsCreated
      };
    } catch (error) {
      logger.error(`Risk detection failed for school ${schoolId}:`, error);
      throw error;
    }
  }
}

module.exports = new RiskDetectionService();
