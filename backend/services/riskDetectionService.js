const Student = require('../models/Student');
const Attendance = require('../models/Attendance');
const Performance = require('../models/Performance');
const RiskFlag = require('../models/RiskFlag');
const Settings = require('../models/Settings');
const logger = require('../utils/logger');

class RiskDetectionService {
  /**
   * Run risk detection for a specific student
   */
  async detectRisksForStudent(studentId, schoolId, userId) {
    try {
      const student = await Student.findById(studentId);
      if (!student) {
        throw new Error('Student not found');
      }

      const settings = await Settings.getOrCreateForSchool(schoolId);
      const risks = [];

      // Check attendance risks
      if (settings.riskRules.attendance.enabled) {
        const attendanceRisk = await this.checkAttendanceRisk(studentId, settings.riskRules.attendance);
        if (attendanceRisk) {
          risks.push(attendanceRisk);
        }
      }

      // Check performance risks
      if (settings.riskRules.performance.enabled) {
        const performanceRisk = await this.checkPerformanceRisk(studentId, settings.riskRules.performance);
        if (performanceRisk) {
          risks.push(performanceRisk);
        }
      }

      // Check socioeconomic risks
      if (settings.riskRules.socioeconomic.enabled) {
        const socioeconomicRisk = await this.checkSocioeconomicRisk(student, settings.riskRules.socioeconomic);
        if (socioeconomicRisk) {
          risks.push(socioeconomicRisk);
        }
      }

      // Check distance to school risks
      const distanceRisk = await this.checkDistanceRisk(student);
      if (distanceRisk) {
        risks.push(distanceRisk);
      }

      // Check combined risks
      if (settings.riskRules.combined.enabled && risks.length >= 2) {
        const combinedRisk = await this.checkCombinedRisk(risks, settings.riskRules.combined);
        if (combinedRisk) {
          risks.push(combinedRisk);
        }
      }

      // Create risk flags for new risks
      const createdFlags = [];
      for (const risk of risks) {
        // Check if similar flag already exists
        const existingFlag = await RiskFlag.findOne({
          studentId,
          type: risk.type,
          isActive: true,
          severity: risk.severity
        });

        if (!existingFlag) {
          const flag = await RiskFlag.create({
            studentId,
            schoolId,
            ...risk,
            createdBy: userId,
            autoGenerated: true
          });
          createdFlags.push(flag);

          // Notify admins immediately for HIGH and CRITICAL risk flags
          if (['HIGH', 'CRITICAL'].includes(risk.severity)) {
            const { notifyAdminOfStudentRisk } = require('../utils/adminNotificationService');
            await notifyAdminOfStudentRisk(
              studentId,
              risk.severity,
              `New ${risk.severity} risk flag detected: ${risk.title}. ${risk.description}`,
              risk.type
            );

            // Automatically notify parents/guardians for HIGH and CRITICAL risk flags
            const { notifyParentsOfRisk } = require('../utils/notificationService');
            const riskDescription = `${risk.title}. ${risk.description}`;
            notifyParentsOfRisk(studentId, risk.severity, riskDescription).catch(err => {
              logger.error('Error notifying parents of new risk flag:', err);
            });
          }
        }
      }

      // Update student risk level (this will also notify admins if overall risk is at-risk)
      await this.updateStudentRiskLevel(studentId);

      logger.info(`Risk detection completed for student ${studentId}`, {
        risksDetected: risks.length,
        flagsCreated: createdFlags.length
      });

      return {
        risksDetected: risks.length,
        flagsCreated: createdFlags.length,
        flags: createdFlags
      };
    } catch (error) {
      logger.error(`Risk detection failed for student ${studentId}:`, error);
      throw error;
    }
  }

  /**
   * Check attendance-based risks
   * Refined: Only flag as CRITICAL/HIGH if absent 10+ days out of 20 school days (2 weeks out of 4 weeks)
   * This is 50% absence rate over a month (assuming 5 days per week)
   */
  async checkAttendanceRisk(studentId, rules) {
    // Calculate monthly attendance: 4 weeks * 5 days = 20 school days
    // Check last 28-30 days to capture a full month of school days
    const daysToCheck = 30; // Check last 30 calendar days
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - daysToCheck);
    startDate.setHours(0, 0, 0, 0);
    
    const endDate = new Date();
    endDate.setHours(23, 59, 59, 999);

    // Get all attendance records in the period
    const allAttendance = await Attendance.find({
      studentId,
      date: { $gte: startDate, $lte: endDate }
    }).sort({ date: -1 });

    // Filter to only count school days (exclude weekends if needed, but for now count all records)
    // Count only ABSENT status (not EXCUSED, as EXCUSED might be legitimate)
    const absences = allAttendance.filter(a => a.status === 'ABSENT').length;
    const totalSchoolDays = allAttendance.length;
    
    // Calculate expected school days: approximately 20 days in a month (4 weeks * 5 days)
    // Use actual records if available, otherwise estimate
    const expectedSchoolDays = totalSchoolDays > 0 ? totalSchoolDays : 20;
    
    // Critical/High threshold: 10 absences out of 20 school days (50% absence rate)
    const criticalThreshold = 10;
    const highThreshold = 10; // Same threshold for both HIGH and CRITICAL
    
    // Medium threshold: 6-9 absences (30-45% absence rate)
    const mediumThreshold = 6;

    if (absences >= criticalThreshold) {
      const absenceRate = totalSchoolDays > 0 ? ((absences / totalSchoolDays) * 100).toFixed(1) : 'N/A';
      return {
        type: 'ATTENDANCE',
        severity: absences >= 12 ? 'CRITICAL' : 'HIGH', // 12+ absences = CRITICAL, 10-11 = HIGH
        title: `${absences >= 12 ? 'Critical' : 'High'} Absenteeism: ${absences} absences in ${totalSchoolDays} school days`,
        description: `Student has been absent ${absences} times out of ${totalSchoolDays} school days (${absenceRate}% absence rate) in the last month. This indicates ${absences >= 12 ? 'critical' : 'high'} dropout risk requiring immediate attention.`,
        data: {
          attendanceData: {
            absences: absences,
            totalSchoolDays: totalSchoolDays,
            absenceRate: absenceRate,
            period: 'Last 30 days (monthly)',
            dates: allAttendance.filter(a => a.status === 'ABSENT').map(a => a.date)
          }
        }
      };
    } else if (absences >= mediumThreshold) {
      const absenceRate = totalSchoolDays > 0 ? ((absences / totalSchoolDays) * 100).toFixed(1) : 'N/A';
      return {
        type: 'ATTENDANCE',
        severity: 'MEDIUM',
        title: `Moderate Absenteeism: ${absences} absences in ${totalSchoolDays} school days`,
        description: `Student has been absent ${absences} times out of ${totalSchoolDays} school days (${absenceRate}% absence rate) in the last month. Monitor attendance patterns closely.`,
        data: {
          attendanceData: {
            absences: absences,
            totalSchoolDays: totalSchoolDays,
            absenceRate: absenceRate,
            period: 'Last 30 days (monthly)',
            dates: allAttendance.filter(a => a.status === 'ABSENT').map(a => a.date)
          }
        }
      };
    }

    return null;
  }

  /**
   * Check performance-based risks
   * Refined: Only flag as CRITICAL/HIGH if overall average performance is 39% (F grade) or below
   * This prevents flagging students with minor performance issues as high risk
   */
  async checkPerformanceRisk(studentId, rules) {
    // Get recent performance records (last academic year)
    const currentYear = new Date().getFullYear();
    const recentPerformances = await Performance.find({
      studentId,
      academicYear: { $gte: currentYear - 1 }
    }).sort({ createdAt: -1 });

    if (recentPerformances.length === 0) {
      return null;
    }

    // Calculate overall average performance percentage
    let totalScore = 0;
    let totalMaxScore = 0;
    let validRecords = 0;

    recentPerformances.forEach(record => {
      if (record.score !== undefined && record.maxScore && record.maxScore > 0) {
        totalScore += record.score;
        totalMaxScore += record.maxScore;
        validRecords++;
      }
    });

    if (validRecords === 0) {
      return null;
    }

    const overallAverage = (totalScore / totalMaxScore) * 100;
    const overallAverageRounded = parseFloat(overallAverage.toFixed(1));

    // Critical/High threshold: 39% or below (F grade)
    const criticalThreshold = 39;

    // Check overall average performance first
    if (overallAverageRounded <= criticalThreshold) {
      const severity = overallAverageRounded <= 30 ? 'CRITICAL' : 'HIGH';
      return {
        type: 'PERFORMANCE',
        severity: severity,
        title: `${severity === 'CRITICAL' ? 'Critical' : 'High'} Performance: ${overallAverageRounded}% average`,
        description: `Student's overall average performance is ${overallAverageRounded}% (F grade), which is ${severity === 'CRITICAL' ? 'critically' : 'significantly'} below the passing threshold. This indicates ${severity === 'CRITICAL' ? 'critical' : 'high'} academic risk requiring immediate intervention.`,
        data: {
          performanceData: {
            overallAverage: overallAverageRounded,
            totalRecords: validRecords,
            totalScore: totalScore,
            totalMaxScore: totalMaxScore,
            threshold: criticalThreshold
          }
        }
      };
    }

    // Check for significant score drops (only if overall average is above 39%)
    // This is less severe than overall poor performance
    const subjects = [...new Set(recentPerformances.map(p => p.subject))];
    for (const subject of subjects) {
      const subjectPerformances = recentPerformances
        .filter(p => p.subject === subject)
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      if (subjectPerformances.length >= 2) {
        const current = subjectPerformances[0];
        const previous = subjectPerformances[1];
        
        // Calculate percentage drop
        const currentPercentage = current.maxScore > 0 ? (current.score / current.maxScore) * 100 : 0;
        const previousPercentage = previous.maxScore > 0 ? (previous.score / previous.maxScore) * 100 : 0;
        const percentageDrop = previousPercentage - currentPercentage;
        
        // Only flag if current score is also below 50% AND dropped significantly
        if (currentPercentage <= 50 && percentageDrop >= 20) {
          return {
            type: 'PERFORMANCE',
            severity: 'MEDIUM',
            title: `Performance Decline in ${subject}`,
            description: `Score in ${subject} dropped from ${previousPercentage.toFixed(1)}% to ${currentPercentage.toFixed(1)}% (${percentageDrop.toFixed(1)}% drop). Current performance is below 50%. Monitor progress.`,
            data: {
              performanceData: {
                subject,
                currentScore: current.score,
                currentMaxScore: current.maxScore,
                currentPercentage: currentPercentage.toFixed(1),
                previousScore: previous.score,
                previousMaxScore: previous.maxScore,
                previousPercentage: previousPercentage.toFixed(1),
                percentageDrop: percentageDrop.toFixed(1)
              }
            }
          };
        }
      }
    }

    return null;
  }

  /**
   * Check socioeconomic risks
   */
  async checkSocioeconomicRisk(student, rules) {
    const riskFactors = [];

    if (student.socioEconomic.ubudeheLevel <= rules.highRiskFactors.ubudeheLevel) {
      riskFactors.push(`Ubudehe Level ${student.socioEconomic.ubudeheLevel} (extreme poverty)`);
    }

    if (!student.socioEconomic.hasParents && rules.highRiskFactors.noParents) {
      riskFactors.push('No parents (orphan)');
    }

    // Family stability: false (unstable) = risk, true (stable) = no risk
    if (!student.socioEconomic.familyStability && rules.highRiskFactors.familyStability) {
      riskFactors.push('Family stability concerns reported');
    }

    if (riskFactors.length >= 2) {
      return {
        type: 'SOCIOECONOMIC',
        severity: 'HIGH',
        title: 'Multiple Socioeconomic Risk Factors',
        description: `Student has multiple socioeconomic risk factors: ${riskFactors.join(', ')}`,
        data: {
          socioeconomicData: {
            ubudeheLevel: student.socioEconomic.ubudeheLevel,
            hasParents: student.socioEconomic.hasParents,
            familyStability: student.socioEconomic.familyStability,
            riskFactors
          }
        }
      };
    } else if (riskFactors.length === 1) {
      return {
        type: 'SOCIOECONOMIC',
        severity: 'MEDIUM',
        title: 'Socioeconomic Risk Factor',
        description: `Student has a socioeconomic risk factor: ${riskFactors[0]}`,
        data: {
          socioeconomicData: {
            ubudeheLevel: student.socioEconomic.ubudeheLevel,
            hasParents: student.socioEconomic.hasParents,
            familyStability: student.socioEconomic.familyStability,
            riskFactors
          }
        }
      };
    }

    return null;
  }

  /**
   * Check distance to school risks
   */
  async checkDistanceRisk(student) {
    if (!student.socioEconomic.distanceToSchoolKm) {
      return null;
    }

    const distance = student.socioEconomic.distanceToSchoolKm;

    if (distance >= 7) {
      return {
        type: 'DISTANCE',
        severity: 'CRITICAL',
        title: `Critical Distance: ${distance} km from school`,
        description: `Student lives ${distance} kilometers from school, exceeding the critical threshold of 7 km. This distance creates significant barriers to regular attendance.`,
        data: {
          distanceData: {
            distanceKm: distance,
            threshold: 7,
            riskLevel: 'CRITICAL'
          }
        }
      };
    } else if (distance >= 5) {
      return {
        type: 'DISTANCE',
        severity: 'HIGH',
        title: `High Distance: ${distance} km from school`,
        description: `Student lives ${distance} kilometers from school, indicating high dropout risk due to distance barriers.`,
        data: {
          distanceData: {
            distanceKm: distance,
            threshold: 5,
            riskLevel: 'HIGH'
          }
        }
      };
    } else if (distance >= 3) {
      return {
        type: 'DISTANCE',
        severity: 'MEDIUM',
        title: `Moderate Distance: ${distance} km from school`,
        description: `Student lives ${distance} kilometers from school. Monitor attendance patterns closely.`,
        data: {
          distanceData: {
            distanceKm: distance,
            threshold: 3,
            riskLevel: 'MEDIUM'
          }
        }
      };
    }

    return null;
  }

  /**
   * Check combined risks (escalate severity)
   */
  async checkCombinedRisk(risks, rules) {
    const mediumRisks = risks.filter(r => r.severity === 'MEDIUM');
    const hasAttendance = risks.some(r => r.type === 'ATTENDANCE');
    const hasPerformance = risks.some(r => r.type === 'PERFORMANCE');

    if (mediumRisks.length >= rules.escalateWhen.multipleMediumFlags) {
      return {
        type: 'COMBINED',
        severity: 'HIGH',
        title: 'Multiple Risk Factors Detected',
        description: `Student has ${mediumRisks.length} medium-risk factors that together indicate high dropout risk.`,
        data: {
          additionalInfo: {
            riskTypes: risks.map(r => r.type),
            escalationReason: 'Multiple medium-risk factors'
          }
        }
      };
    }

    if (hasAttendance && hasPerformance && rules.escalateWhen.attendanceAndPerformance) {
      return {
        type: 'COMBINED',
        severity: 'HIGH',
        title: 'Attendance and Performance Issues',
        description: 'Student has both attendance and performance issues, indicating high dropout risk.',
        data: {
          additionalInfo: {
            riskTypes: risks.map(r => r.type),
            escalationReason: 'Combined attendance and performance issues'
          }
        }
      };
    }

    return null;
  }

  /**
   * Update student risk level based on active flags
   */
  async updateStudentRiskLevel(studentId) {
    const summary = await RiskFlag.getStudentSummary(studentId);
    const student = await Student.findById(studentId);
    
    if (student) {
      const previousRiskLevel = student.riskLevel;
      student.riskLevel = summary.overallRisk;
      await student.save();

      // Notify admins if risk level changed to or is at-risk
      if (['MEDIUM', 'HIGH', 'CRITICAL'].includes(summary.overallRisk)) {
        const { notifyAdminOfStudentRisk } = require('../utils/adminNotificationService');
        let reason = '';
        if (previousRiskLevel !== summary.overallRisk) {
          reason = `Risk level changed from ${previousRiskLevel || 'LOW'} to ${summary.overallRisk}.`;
        } else {
          reason = `Student has active risk flags with ${summary.overallRisk} risk level.`;
        }
        
        // Determine risk type from flags
        const activeFlags = await RiskFlag.find({ studentId, isActive: true, isResolved: false });
        const riskTypes = [...new Set(activeFlags.map(f => f.type))];
        const riskType = riskTypes.length > 0 ? riskTypes[0] : 'GENERAL';
        
        await notifyAdminOfStudentRisk(studentId, summary.overallRisk, reason, riskType);

        // Automatically notify parents/guardians if risk level changed to HIGH or CRITICAL
        if (previousRiskLevel !== summary.overallRisk && (summary.overallRisk === 'HIGH' || summary.overallRisk === 'CRITICAL')) {
          const { notifyParentsOfRisk } = require('../utils/notificationService');
          notifyParentsOfRisk(studentId, summary.overallRisk, reason).catch(err => {
            logger.error('Error notifying parents of risk level change:', err);
          });
        }
      }
    }

    return summary.overallRisk;
  }

  /**
   * Run risk detection for all students in a school
   */
  async detectRisksForSchool(schoolId, userId) {
    try {
      const students = await Student.find({ schoolId, isActive: true });
      
      logger.info(`Starting risk detection for ${students.length} students in school ${schoolId}`);

      let processed = 0;
      let flagsCreated = 0;

      for (const student of students) {
        try {
          const result = await this.detectRisksForStudent(student._id, schoolId, userId);
          flagsCreated += result.flagsCreated;
          processed++;
        } catch (error) {
          logger.error(`Failed to detect risks for student ${student._id}:`, error);
        }
      }

      logger.info(`Risk detection completed for school ${schoolId}`, {
        studentsProcessed: processed,
        totalFlagsCreated: flagsCreated
      });

      return {
        studentsProcessed: processed,
        totalFlagsCreated: flagsCreated
      };
    } catch (error) {
      logger.error(`Risk detection failed for school ${schoolId}:`, error);
      throw error;
    }
  }
}

module.exports = new RiskDetectionService();
